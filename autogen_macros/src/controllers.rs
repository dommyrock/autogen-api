/*
The reason we need to use Box<dyn Controller> instead of just dyn Controller is because trait objects are dynamically sized types (DSTs), and Rust requires values to have a known size at compile time. By boxing the trait object, we’re storing it on the heap, which allows us to work with it as if it were a regular, statically sized type.

In the context of the register_controllers function, we’re using Box<dyn Controller> so that we can store controllers of different types in the same vector. Each controller might be a different type, but they all implement the Controller trait, so we can treat them uniformly by boxing them and storing them as trait objects. This allows us to iterate over the vector and call methods on each controller, regardless of its concrete type. This is a form of polymorphism, a common pattern in object-oriented programming.
*/

use axum::Router;
use proc_macro::TokenStream;
use quote::quote;

// fn register_controllers(router: Router<BoxRoute>, controllers: Vec<Box<dyn Controller>>) -> Router<BoxRoute> {
//    let mut router = router;
//    for controller in controllers {
//        router = router.route(controller.path(), get(controller.get).post(controller.post));
//    }
//    router
// }

//Controllers should look somehting like this, meaning i should remove them from app/src/main.rs 
/*
pub trait Controller: DeserializeOwned + Send + 'static {}

async fn get_resource<R: Controller>(Json(_payload): Json<R>) -> impl IntoResponse {
    (StatusCode::OK, format!("Hi"))
}

*/

pub(crate) fn expand(input: TokenStream) -> TokenStream {
    let ast: syn::DeriveInput = syn::parse(input).unwrap();
    let name = &ast.ident;

    let gen = quote! {
        pub struct #name Controller;

        impl #name Controller {
            pub async fn get() -> impl Reply {
                format!("GET endpoint for {}", stringify!(#name))
            }

            pub async fn post() -> impl Reply {
                format!("POST endpoint for {}", stringify!(#name))
            }
        }
    };

    gen.into()
}

/*
When you use a procedural macro in Rust, the code generated by the macro is inserted into your program at the location where the macro is invoked. This happens during the compilation process, before the final binary is produced.

Here's a simplified overview of the process:

1. **Parsing:** The Rust compiler parses your source code into an Abstract Syntax Tree (AST).
2. **Expansion:** The compiler expands macros, replacing each macro invocation with the code generated by the macro. This is where procedural macros do their work. They take in the tokens representing the input to the macro, and output the tokens representing the generated code. The output tokens are then parsed into AST nodes and spliced into the rest of the program's AST in place of the macro invocation.
3. **Analysis:** The compiler performs various checks on the expanded AST, such as type checking, borrow checking, and so on.
4. **Code Generation:** The compiler translates the AST into LLVM Intermediate Representation (IR), which is then optimized.
5. **Compilation:** The LLVM backend compiles the IR down to machine code, producing the final binary.

So, the code generated by a procedural macro doesn't go into a separate file or location. Instead, it becomes a part of your program's source code, and goes through the same compilation process as the rest of your code. The generated code is not typically visible to you unless you use tools or compiler flags to inspect it, such as `cargo expand` to see the result of macro expansion. 
*/